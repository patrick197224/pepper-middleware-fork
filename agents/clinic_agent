#!/usr/bin/env python3
"""
Multi-Agent System for Clinic Patient Communication

This script implements a multi-agent system using OpenAI Agents Framework to provide
patient communication, clinic information retrieval, and appointment management.

The system consists of:
1. The Orchestrator: Automatically routes patient requests to the appropriate agent
2. The Receptionist: Answers questions about the clinic using RAG system
3. The Appointment Manager: Handles appointment scheduling and database operations

Required packages:
pip install langchain-openai langchain-classic langchain-community langchain-core langchain-text-splitters chromadb PyPDF2 pandas
"""

import os
import warnings
import sqlite3
import requests
import tempfile
import paramiko
import re
from typing import Dict, Optional, List
from datetime import datetime, timedelta
from contextlib import contextmanager
from agents import Agent, Runner, function_tool, SQLiteSession


# Import Pepper audio module
try:
    import sys
    import importlib.util
    # Handle module name with dash - get the directory of this file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    pepper_audio_path = os.path.join(current_dir, "pepper-audio.py")
    spec = importlib.util.spec_from_file_location("pepper_audio", pepper_audio_path)
    pepper_audio = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(pepper_audio)
    speech_to_text_from_pepper = pepper_audio.speech_to_text_from_pepper
    speech_to_text_interactive = pepper_audio.speech_to_text_interactive
    PEPPER_AUDIO_AVAILABLE = True
except Exception as e:
    print(f"Warning: Could not load pepper-audio module: {e}")
    print("Install required packages: pip install paramiko openai")
    PEPPER_AUDIO_AVAILABLE = False
    speech_to_text_from_pepper = None
    speech_to_text_interactive = None

# Import audio.py module for get_user_text()
try:
    import sys
    import importlib.util
    current_dir = os.path.dirname(os.path.abspath(__file__))
    audio_path = os.path.join(current_dir, "audio.py")
    spec = importlib.util.spec_from_file_location("audio_module", audio_path)
    audio_module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(audio_module)
    get_user_text = audio_module.get_user_text
    AUDIO_MODULE_AVAILABLE = True
except Exception as e:
    print(f"Warning: Could not load audio module: {e}")
    AUDIO_MODULE_AVAILABLE = False
    get_user_text = None

# ============================================================================
# PEPPER ROBOT CONFIGURATION
# ============================================================================

PEPPER_MIDDLEWARE_URL = os.environ.get("PEPPER_MIDDLEWARE_URL", "http://<ip_address>:5000")
TTS_LANGUAGE = os.environ.get("TTS_LANGUAGE", "English")
TTS_ANIMATED = True  # Use animated speech with gestures

# Suppress ResourceWarnings from asyncio (they're harmless)
warnings.filterwarnings("ignore", category=ResourceWarning)

# ============================================================================
# RAG SYSTEM INITIALIZATION
# ============================================================================

print("Initializing RAG system for clinic information...")

try:
    from langchain_openai import ChatOpenAI, OpenAIEmbeddings
    from langchain_classic.chains.retrieval import create_retrieval_chain
    from langchain_classic.chains.combine_documents import create_stuff_documents_chain
    from langchain_core.prompts import ChatPromptTemplate
    from langchain_community.vectorstores import Chroma
    from langchain_text_splitters import RecursiveCharacterTextSplitter
    import glob
    import PyPDF2
    
    # Load documents
    documents = []
    for filename in glob.glob("*.txt"):
        with open(filename, "r", encoding="utf-8") as f:
            documents.append(f.read())
    
    for filename in glob.glob("*.pdf"):
        try:
            with open(filename, "rb") as f:
                reader = PyPDF2.PdfReader(f)
                pdf_text = "".join(page.extract_text() or "" for page in reader.pages)
                documents.append(pdf_text)
        except Exception as e:
            print(f"Error reading {filename}: {e}")
    
    if not documents:
        print("Warning: No documents found. RAG system will not work properly.")
        rag_qa_chain = None
    else:
        text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)
        docs = text_splitter.create_documents(documents)
        
        embeddings = OpenAIEmbeddings(
            openai_api_key=os.environ["OPENAI_API_KEY"],
            model="text-embedding-ada-002"
        )
        vectorstore = Chroma.from_documents(docs, embeddings)
        
        llm = ChatOpenAI(
            openai_api_key=os.environ["OPENAI_API_KEY"],
            model_name="gpt-3.5-turbo"
        )
        
        system_prompt = (
            "Use the following context about GreenOak Family Practice clinic to answer the question. "
            "If the information is not in the context, say so. Be helpful and accurate.\n\n"
            "{context}"
        )
        prompt = ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            ("human", "{input}")
        ])
        
        combine_docs_chain = create_stuff_documents_chain(llm, prompt)
        rag_qa_chain = create_retrieval_chain(vectorstore.as_retriever(), combine_docs_chain)
        print(f"âœ“ RAG system initialized with {len(documents)} document(s)")
        
except ImportError as e:
    print(f"Warning: Could not import LangChain modules: {e}")
    print("RAG functionality will be disabled. Install with: pip install langchain-openai langchain-classic langchain-community langchain-core langchain-text-splitters chromadb PyPDF2")
    rag_qa_chain = None
except Exception as e:
    print(f"Error initializing RAG system: {e}")
    rag_qa_chain = None

# ============================================================================
# APPOINTMENT DATABASE - REMOTE CONFIGURATION
# ============================================================================

# Remote database configuration
REMOTE_DB_HOST = os.environ.get("REMOTE_DB_HOST", "172.30.36.71")
REMOTE_DB_USER = os.environ.get("REMOTE_DB_USER", "hcr")
REMOTE_DB_PASSWORD = os.environ.get("REMOTE_DB_PASSWORD", "daslaborausglas7")
REMOTE_DB_PATH = os.environ.get("REMOTE_DB_PATH", "~/server/appointments.db")
USE_REMOTE_DB = os.environ.get("USE_REMOTE_DB", "true").lower() == "true"

# Local database path (fallback or for testing)
APPOINTMENTS_DB = "appointments.db"

# ============================================================================
# REMOTE DATABASE ACCESS HELPER
# ============================================================================

@contextmanager
def get_db_connection():
    """
    Context manager that provides a database connection.
    If USE_REMOTE_DB is True, it downloads the remote database, works with it locally,
    then uploads it back. Otherwise, it uses the local database.
    """
    if USE_REMOTE_DB:
        # Remote database mode - download, work locally, upload back
        local_db_path = None
        ssh = None
        sftp = None
        
        try:
            # Expand ~ in remote path
            remote_db_path = REMOTE_DB_PATH.replace('~', '/home/' + REMOTE_DB_USER)
            
            # Create temporary local file
            temp_fd, local_db_path = tempfile.mkstemp(suffix='.db', prefix='appointments_')
            os.close(temp_fd)
            
            # Connect via SSH
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            # Try password authentication first, then key-based
            try:
                if REMOTE_DB_PASSWORD:
                    ssh.connect(REMOTE_DB_HOST, username=REMOTE_DB_USER, password=REMOTE_DB_PASSWORD, timeout=10)
                else:
                    # Try using default SSH key locations
                    ssh.connect(REMOTE_DB_HOST, username=REMOTE_DB_USER, timeout=10)
            except paramiko.AuthenticationException:
                # Try with key file
                key_path = os.path.expanduser("~/.ssh/id_rsa")
                if os.path.exists(key_path):
                    private_key = paramiko.RSAKey.from_private_key_file(key_path)
                    ssh.connect(REMOTE_DB_HOST, username=REMOTE_DB_USER, pkey=private_key, timeout=10)
                else:
                    raise Exception(f"Could not authenticate to {REMOTE_DB_USER}@{REMOTE_DB_HOST}. "
                                  f"Set REMOTE_DB_PASSWORD environment variable or configure SSH keys.")
            
            sftp = ssh.open_sftp()
            
            # Download remote database if it exists
            try:
                sftp.get(remote_db_path, local_db_path)
                print(f"[DB] Downloaded remote database from {REMOTE_DB_HOST}:{remote_db_path}")
            except FileNotFoundError:
                print(f"[DB] Remote database not found, creating new one at {remote_db_path}")
                # Create empty database file locally
                conn = sqlite3.connect(local_db_path)
                conn.close()
            
            # Work with local database
            conn = sqlite3.connect(local_db_path)
            try:
                yield conn
            finally:
                conn.close()
            
            # Upload back to remote server
            sftp.put(local_db_path, remote_db_path)
            print(f"[DB] Uploaded database back to {REMOTE_DB_HOST}:{remote_db_path}")
            
        except Exception as e:
            print(f"[DB] Error accessing remote database: {e}")
            raise
        finally:
            # Cleanup
            if sftp:
                sftp.close()
            if ssh:
                ssh.close()
            if local_db_path and os.path.exists(local_db_path):
                os.remove(local_db_path)
    else:
        # Local database mode
        conn = sqlite3.connect(APPOINTMENTS_DB)
        try:
            yield conn
        finally:
            conn.close()

def init_appointments_db():
    """Initialize the appointments database with the remote schema"""
    with get_db_connection() as conn:
        cursor = conn.cursor()
        # Use the remote schema: id, date, time, patient, notes
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS appointments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT NOT NULL,
                time TEXT NOT NULL,
                patient TEXT NOT NULL,
                notes TEXT
            )
        """)
        conn.commit()

# Initialize database on import
init_appointments_db()

# ============================================================================
# PEPPER ROBOT TTS FUNCTIONS
# ============================================================================

def send_to_pepper_tts(text: str, language: str = None, animated: bool = None) -> bool:
    """
    Send text to Pepper robot's text-to-speech system.
    
    Args:
        text: The text for Pepper to speak
        language: Language for TTS (default: TTS_LANGUAGE)
        animated: Whether to use animated speech (default: TTS_ANIMATED)
    
    Returns:
        True if successful, False otherwise
    """
    if language is None:
        language = TTS_LANGUAGE
    if animated is None:
        animated = TTS_ANIMATED
    
    try:
        url = f"{PEPPER_MIDDLEWARE_URL}/robot/tts/say"
        payload = {
            "text": text,
            "language": language,
            "isAnimated": animated
        }
        response = requests.post(url, json=payload, timeout=10)
        
        if response.status_code == 200:
            print(f"[TTS] Successfully sent to Pepper: {text[:50]}...")
            return True
        else:
            print(f"[TTS] Error sending to Pepper: {response.status_code}")
            return False
    except requests.exceptions.RequestException as e:
        print(f"[TTS] Connection error: {e}")
        return False

def send_to_pepper_tablet(text: str) -> bool:
    """
    Send text summary to Pepper robot's tablet display.
    
    The tablet template expects an iterable (list), and the endpoint uses literal_eval()
    on the URL parameter. We need to format the text as a Python list literal string.
    
    Args:
        text: The text summary to display on the tablet
    
    Returns:
        True if successful, False otherwise
    """
    try:
        # The tablet template loops over text with {% for key in text %}, so it expects a list
        # The endpoint uses literal_eval() on the URL parameter, so we need a valid Python literal
        # Split by | if present, otherwise use the whole text as a single item
        if " | " in text:
            # Split by | and create a list, using repr() for proper escaping
            items = [item.strip() for item in text.split("|")]
            # Format as Python list literal string using repr() for each item
            text_literal = "[" + ", ".join([repr(item) for item in items]) + "]"
        else:
            # Single item, wrap in list using repr() for proper escaping
            text_literal = f"[{repr(text)}]"
        
        url = f"{PEPPER_MIDDLEWARE_URL}/robot/tablet/text"
        payload = {"text": text_literal}
        response = requests.post(url, json=payload, timeout=10)
        
        if response.status_code == 200:
            print(f"[Tablet] Successfully sent summary to Pepper tablet: {text[:50]}...")
            return True
        else:
            print(f"[Tablet] Error sending to Pepper tablet: {response.status_code}")
            if response.text:
                print(f"[Tablet] Response: {response.text[:200]}")
            return False
    except requests.exceptions.RequestException as e:
        print(f"[Tablet] Connection error: {e}")
        return False
    except Exception as e:
        print(f"[Tablet] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        return False

def get_recent_appointments(limit: int = 1, patient_name: Optional[str] = None) -> List[tuple]:
    """
    Get the most recent appointment(s) from the database.
    
    Args:
        limit: Maximum number of appointments to return (default: 1)
        patient_name: Optional patient name to filter by
    
    Returns:
        List of appointment tuples: (id, date, time, patient, notes)
    """
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            
            if patient_name:
                cursor.execute("""
                    SELECT id, date, time, patient, notes
                    FROM appointments
                    WHERE patient LIKE ?
                    ORDER BY date DESC, time DESC
                    LIMIT ?
                """, (f"%{patient_name}%", limit))
            else:
                cursor.execute("""
                    SELECT id, date, time, patient, notes
                    FROM appointments
                    ORDER BY date DESC, time DESC
                    LIMIT ?
                """, (limit,))
            
            return cursor.fetchall()
    except Exception as e:
        print(f"[DB] Error getting recent appointments: {e}")
        return []